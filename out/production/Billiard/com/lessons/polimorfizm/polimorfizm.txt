
В О.О.П. наследование и полиморфизм - это разные вещи.
* Наследоваться могут методы (функции) и поля (переменные), но по разному...;
* Полиморфизм - (часть наследования) переопределение реализации метода (функции), а все остальное - это перегрузка метода (функции)...;

  В наследовании существуют такие понятия как: "круг доверия" (область видимости) куда могут входить особенные классы-друзья.
Каждый отдельный пакет - в Java определяет отдельную область видимости и классы которые находятся внутри этого пакета автоматически попадают в круг доверия
(тобиш, становятся между собой друзьями)...


  Каждый класс представляет собой сущность, которая состоит из полей (переменных - определяют состояние сущности) и методов (функций - определяют поведения
сущности).
  Внутри класса поля и методы зависимы, тобиш гарантировать работоспособность класса разработчик может только в случае если поля и методы работают согласовано
инначе функциональность сущности будет неправильная. В случае если кто-то из-вне (который незнает ничего о внутреней структуре...) вмешивается во внутреннюю
работу класса - тогда в этом случае гарантировать правильную функциональность уже нельзя...
  Классы-друзья, которые в одной области видимости, знают о том как устроены классы внутри этого пакета и поэтому онпи имеют доверия к доступу ко всем
членам класса...

Например:
1) задача для вычисления площади, периметра, стороны, ... геометрических фигур.
   Такие величины (переменные) как: 'a', 'b', 'c', 'r', 'R', 'd', 'h', 'l', 'S', 'P', ... - считаются общеприйнятыми, которые указывают соответственно 'длину',
   'ширину', 'высоту', 'внутренниый/внешний радиус', 'диаметр', 'длину окружности', 'периметр', ... . Конечно же, если доверенный класс-наследник (с того же
   пакета), который реализует определеный тип фигуры будет унаследован от своего родителя базового-класса - тогда в этом случае есть смысл общеприйнятые
   величины (переменные) сделать доступными в классах-наследниках внутри пакета, но запретить доступ к ним из-вне пакета...;
2) спецыфические задачи по тестированию модулей/классов... .
   Когда есть такая необходимость чтобы предоставить расширеный (специфический) интерфейс для группы тестировщиков в команде где разрабатываются библиотеки...
   Именно такой расширеный функциональный интерфейс позволил-бы получить более детальную информацию о состоянии процессов...
3) Но обычно, механизм наследования в чистом виде не используется, а только в примесси с другими технологиями: полиморфизм, инкапсуляция, композиция, делегирование, ...
   * изначально существует реализация (некоторого сервиса) корневого API-класса, который имеет много разных собственных методов. Обычно такой API-класс бывает очень громоздкий и в
     нем реализовано много разносторонних методов;
   * чтобы как-то упростить и разделить/сгруппировать такие разностороние методы - для этой цели дробят/делают несколько классов-наследников внутри которых группируются методы...
     Поэтому, в отличие от своего корневого родительского-класса, классы-наследники имеют более упрощенный функционал. (В этом случае механизм наследование можно использовать вместе с
     композицией...) И переопределить реализацию методов используя свой родительский ('super') класс...;
   * А для того чтобы ограничить/закрыть доступ к другим/остальным методам унаследованных от родительского класса - нужно поставить (в корневом, родительском классе) им модификатор 'protected'.
     Модификаторы для полиморфных методов можно изменять, в классах-наследниках, только в сторону повышения видимости...;





(Перегрузка (overload) и переопределение (override) методов в Java) http://ithq.ru/index.php/article/view/peregruzka-overload-i-pereopredelenie-override-metodov-v-java
(Раннее и позднее связывание является одним из проявлений полиморфизма, позволяя выполнять одним оператором вызов различных методов в зависимости от типа объекта) http://www.uchi-it.ru/9/1/13.html

(Особенности применения модификаторов в Java * Модификаторы доступа) http://www.quizful.net/post/features-of-the-application-of-modifiers-in-java
(Java на каждый день и не только. Рекомендации по использованию) http://habrahabr.ru/post/167291/
(Глава 4. Объектная модель Java * Основные принципы ООП) http://umk.portal.kemsu.ru/java/paper/book/gl_4.htm
